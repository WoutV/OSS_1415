[{"1":"\/*","2":" * SonarQube, open source software quality management tool.","3":" * Copyright (C) 2008-2013 SonarSource","4":" * mailto:contact AT sonarsource DOT com","5":" *","6":" * SonarQube is free software; you can redistribute it and\/or","7":" * modify it under the terms of the GNU Lesser General Public","8":" * License as published by the Free Software Foundation; either","9":" * version 3 of the License, or (at your option) any later version.","10":" *","11":" * SonarQube is distributed in the hope that it will be useful,","12":" * but WITHOUT ANY WARRANTY; without even the implied warranty of","13":" * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU","14":" * Lesser General Public License for more details.","15":" *","16":" * You should have received a copy of the GNU Lesser General Public License","17":" * along with this program; if not, write to the Free Software Foundation,","18":" * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.","19":" *\/","20":"package org.sonar.api.utils;","21":"","22":"import com.google.common.collect.Multiset;","23":"import org.apache.commons.collections.Bag;","24":"import org.apache.commons.lang.StringUtils;","25":"import org.apache.commons.lang.math.NumberUtils;","26":"import org.sonar.api.rules.RulePriority;","27":"import org.slf4j.LoggerFactory;","28":"","29":"import java.util.HashMap;","30":"import java.util.Map;","31":"","32":"\/**","33":" * Util class to format key\/value data. Output is a string representation ready to be","34":" * injected into the database","35":" *","36":" * @since 1.10","37":" *\/","38":"public final class KeyValueFormat {","39":"","40":"  private KeyValueFormat() {","41":"  }","42":"","43":"  \/**","44":"   * Transforms a string with the following format : &quot;key1=value1;key2=value2...&quot;","45":"   * into a Map&lt;KEY, VALUE&gt;. Requires to implement the transform(key,value) method","46":"   *","47":"   * @param data        the input string","48":"   * @param transformer the interface to implement","49":"   * @return a Map of &lt;key, value&gt;","50":"   *\/","51":"  public static &lt;KEY, VALUE&gt; Map&lt;KEY, VALUE&gt; parse(String data, Transformer&lt;KEY, VALUE&gt; transformer) {","52":"    Map&lt;String, String&gt; rawData = parse(data);","53":"    Map&lt;KEY, VALUE&gt; map = new HashMap&lt;KEY, VALUE&gt;();","54":"    for (Map.Entry&lt;String, String&gt; entry : rawData.entrySet()) {","55":"      KeyValue&lt;KEY, VALUE&gt; keyVal = transformer.transform(entry.getKey(), entry.getValue());","56":"      if (keyVal != null) {","57":"        map.put(keyVal.getKey(), keyVal.getValue());","58":"      }","59":"    }","60":"    return map;","61":"  }","62":"","63":"  \/**","64":"   * Transforms a string with the following format : &quot;key1=value1;key2=value2...&quot;","65":"   * into a Map&lt;String,String&gt;","66":"   *","67":"   * @param data the string to parse","68":"   * @return a map","69":"   *\/","70":"  public static Map&lt;String, String&gt; parse(String data) {","71":"    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();","72":"    String[] pairs = StringUtils.split(data, &quot;;&quot;);","73":"    for (String pair : pairs) {","74":"      String[] keyValue = StringUtils.split(pair, &quot;=&quot;);","75":"      String key = keyValue[0];","76":"      String value = (keyValue.length == 2 ? keyValue[1] : &quot;&quot;);","77":"      map.put(key, value);","78":"    }","79":"    return map;","80":"  }","81":"","82":"  \/**","83":"   * Transforms a map&lt;KEY,VALUE&gt; into a string with the format : &quot;key1=value1;key2=value2...&quot;","84":"   *","85":"   * @param map the map to transform","86":"   * @return the formatted string","87":"   *\/","88":"  public static &lt;KEY, VALUE&gt; String format(Map&lt;KEY, VALUE&gt; map) {","89":"    StringBuilder sb = new StringBuilder();","90":"    boolean first = true;","91":"    for (Map.Entry&lt;?, ?&gt; entry : map.entrySet()) {","92":"      if (!first) {","93":"        sb.append(&quot;;&quot;);","94":"      }","95":"      sb.append(entry.getKey().toString());","96":"      sb.append(&quot;=&quot;);","97":"      if (entry.getValue() != null) {","98":"        sb.append(entry.getValue());","99":"      }","100":"      first = false;","101":"    }","102":"","103":"    return sb.toString();","104":"  }","105":"","106":"  \/**","107":"   * @since 1.11","108":"   * @deprecated use Multiset from google collections instead of commons-collections bags","109":"   *\/","110":"  public static String format(Bag bag) {","111":"    return format(bag, 0);","112":"  }","113":"","114":"  \/**","115":"   * @since 1.11","116":"   * @deprecated use Multiset from google collections instead of commons-collections bags","117":"   *\/","118":"  public static String format(Bag bag, int var) {","119":"    StringBuilder sb = new StringBuilder();","120":"    boolean first = true;","121":"    for (Object obj : bag.uniqueSet()) {","122":"      if (!first) {","123":"        sb.append(&quot;;&quot;);","124":"      }","125":"      sb.append(obj.toString());","126":"      sb.append(&quot;=&quot;);","127":"      sb.append(bag.getCount(obj) + var);","128":"      first = false;","129":"    }","130":"","131":"    return sb.toString();","132":"  }","133":"","134":"  \/**","135":"   * Transforms a Multiset&lt;?&gt; into a string with the format : &quot;key1=count1;key2=count2...&quot;","136":"   *","137":"   * @param set the set to transform","138":"   * @return the formatted string","139":"   *\/","140":"  public static String format(Multiset&lt;?&gt; set) {","141":"    StringBuilder sb = new StringBuilder();","142":"    boolean first = true;","143":"    for (Multiset.Entry&lt;?&gt; entry : set.entrySet()) {","144":"      if (!first) {","145":"        sb.append(&quot;;&quot;);","146":"      }","147":"      sb.append(entry.getElement().toString());","148":"      sb.append(&quot;=&quot;);","149":"      sb.append(entry.getCount());","150":"      first = false;","151":"    }","152":"    return sb.toString();","153":"  }","154":"","155":"  \/**","156":"   * Transforms a Object... into a string with the format : &quot;object1=object2;object3=object4...&quot;","157":"   *","158":"   * @param objects the object list to transform","159":"   * @return the formatted string","160":"   *\/","161":"  public static String format(Object... objects) {","162":"    StringBuilder sb = new StringBuilder();","163":"    boolean first = true;","164":"    if (objects != null) {","165":"      for (int i = 0; i &lt; objects.length; i++) {","166":"        if (!first) {","167":"          sb.append(&quot;;&quot;);","168":"        }","169":"        sb.append(objects[i++].toString());","170":"        sb.append(&quot;=&quot;);","171":"        sb.append(objects[i]);","172":"        first = false;","173":"      }","174":"    }","175":"    return sb.toString();","176":"  }","177":"","178":"  public interface Transformer&lt;KEY, VALUE&gt; {","179":"    KeyValue&lt;KEY, VALUE&gt; transform(String key, String value);","180":"  }","181":"","182":"  \/**","183":"   * Implementation of Transformer&lt;String, Double&gt;","184":"   *\/","185":"  public static class StringNumberPairTransformer implements Transformer&lt;String, Double&gt; {","186":"","187":"    public KeyValue&lt;String, Double&gt; transform(String key, String value) {","188":"      return new KeyValue&lt;String, Double&gt;(key, toDouble(value));","189":"    }","190":"  }","191":"","192":"  \/**","193":"   * Implementation of Transformer&lt;Double, Double&gt;","194":"   *\/","195":"  public static class DoubleNumbersPairTransformer implements Transformer&lt;Double, Double&gt; {","196":"","197":"    public KeyValue&lt;Double, Double&gt; transform(String key, String value) {","198":"      return new KeyValue&lt;Double, Double&gt;(toDouble(key), toDouble(value));","199":"    }","200":"  }","201":"","202":"  \/**","203":"   * Implementation of Transformer&lt;Integer, Integer&gt;","204":"   *\/","205":"  public static class IntegerNumbersPairTransformer implements Transformer&lt;Integer, Integer&gt; {","206":"","207":"    public KeyValue&lt;Integer, Integer&gt; transform(String key, String value) {","208":"      return new KeyValue&lt;Integer, Integer&gt;(toInteger(key), toInteger(value));","209":"    }","210":"  }","211":"","212":"  \/**","213":"   * Implementation of Transformer&lt;RulePriority, Integer&gt;","214":"   *\/","215":"  public static class RulePriorityNumbersPairTransformer implements Transformer&lt;RulePriority, Integer&gt; {","216":"","217":"    public KeyValue&lt;RulePriority, Integer&gt; transform(String key, String value) {","218":"      try {","219":"        if (StringUtils.isBlank(value)) { value = &quot;0&quot;; }","220":"        return new KeyValue&lt;RulePriority, Integer&gt;(RulePriority.valueOf(key.toUpperCase()), Integer.parseInt(value));","221":"      }","222":"      catch (Exception e) {","223":"        LoggerFactory.getLogger(RulePriorityNumbersPairTransformer.class).warn(&quot;Property &quot; + key + &quot; has invalid value: &quot; + value, e);","224":"        return null;","225":"      }","226":"    }","227":"  }","228":"","229":"  private static Double toDouble(String value) {","230":"    return StringUtils.isBlank(value) ? null : NumberUtils.toDouble(value);","231":"  }","232":"","233":"  private static Integer toInteger(String value) {","234":"    return StringUtils.isBlank(value) ? null : NumberUtils.toInt(value);","235":"  }","236":"}"}]